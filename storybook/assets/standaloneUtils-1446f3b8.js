const T=Symbol(),K=Object.getPrototypeOf,V=new WeakMap,Y=n=>n&&(V.has(n)?V.get(n):K(n)===Object.prototype||K(n)===Array.prototype),q=n=>Y(n)&&n[T]||null,z=(n,O=!0)=>{V.set(n,O)},B=n=>typeof n=="object"&&n!==null,h=new WeakMap,L=new WeakSet,F=(n=Object.is,O=(t,u)=>new Proxy(t,u),g=t=>B(t)&&!L.has(t)&&(Array.isArray(t)||!(Symbol.iterator in t))&&!(t instanceof WeakMap)&&!(t instanceof WeakSet)&&!(t instanceof Error)&&!(t instanceof Number)&&!(t instanceof Date)&&!(t instanceof String)&&!(t instanceof RegExp)&&!(t instanceof ArrayBuffer),j=t=>{switch(t.status){case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t}},p=new WeakMap,w=(t,u,d=j)=>{const c=p.get(t);if((c==null?void 0:c[0])===u)return c[1];const f=Array.isArray(t)?[]:Object.create(Object.getPrototypeOf(t));return z(f,!0),p.set(t,[u,f]),Reflect.ownKeys(t).forEach(E=>{if(Object.getOwnPropertyDescriptor(f,E))return;const l=Reflect.get(t,E),S={value:l,enumerable:!0,configurable:!0};if(L.has(l))z(l,!1);else if(l instanceof Promise)delete S.value,S.get=()=>d(l);else if(h.has(l)){const[i,M]=h.get(l);S.value=w(i,M(),d)}Object.defineProperty(f,E,S)}),Object.preventExtensions(f)},R=new WeakMap,a=[1,1],m=t=>{if(!B(t))throw new Error("object required");const u=R.get(t);if(u)return u;let d=a[0];const c=new Set,f=(r,s=++a[0])=>{d!==s&&(d=s,c.forEach(e=>e(r,s)))};let E=a[1];const l=(r=++a[1])=>(E!==r&&!c.size&&(E=r,i.forEach(([s])=>{const e=s[1](r);e>d&&(d=e)})),d),S=r=>(s,e)=>{const o=[...s];o[1]=[r,...o[1]],f(o,e)},i=new Map,M=(r,s)=>{if(c.size){const e=s[3](S(r));i.set(r,[s,e])}else i.set(r,[s])},W=r=>{var s;const e=i.get(r);e&&(i.delete(r),(s=e[1])==null||s.call(e))},U=r=>(c.add(r),c.size===1&&i.forEach(([e,o],P)=>{const b=e[3](S(P));i.set(P,[e,b])}),()=>{c.delete(r),c.size===0&&i.forEach(([e,o],P)=>{o&&(o(),i.set(P,[e]))})}),v=Array.isArray(t)?[]:Object.create(Object.getPrototypeOf(t)),A=O(v,{deleteProperty(r,s){const e=Reflect.get(r,s);W(s);const o=Reflect.deleteProperty(r,s);return o&&f(["delete",[s],e]),o},set(r,s,e,o){const P=Reflect.has(r,s),b=Reflect.get(r,s,o);if(P&&(n(b,e)||R.has(e)&&n(b,R.get(e))))return!0;W(s),B(e)&&(e=q(e)||e);let D=e;if(e instanceof Promise)e.then(y=>{e.status="fulfilled",e.value=y,f(["resolve",[s],y])}).catch(y=>{e.status="rejected",e.reason=y,f(["reject",[s],y])});else{!h.has(e)&&g(e)&&(D=m(e));const y=!L.has(D)&&h.get(D);y&&M(s,y)}return Reflect.set(r,s,D,o),f(["set",[s],e,b]),!0}});R.set(t,A);const _=[v,l,w,U];return h.set(A,_),Reflect.ownKeys(t).forEach(r=>{const s=Object.getOwnPropertyDescriptor(t,r);"value"in s&&(A[r]=t[r],delete s.value,delete s.writable),Object.defineProperty(v,r,s)}),A})=>[m,h,L,n,O,g,j,p,w,R,a],[N]=F();function G(n={}){return N(n)}function J(n,O,g){const j=h.get(n);let p;const w=[],R=j[3];let a=!1;const t=R(u=>{if(w.push(u),g){O(w.splice(0));return}p||(p=Promise.resolve().then(()=>{p=void 0,a&&O(w.splice(0))}))});return a=!0,()=>{a=!1,t()}}const Q=()=>localStorage.cypress==="true";export{Q as i,G as p,J as s};
//# sourceMappingURL=standaloneUtils-1446f3b8.js.map
